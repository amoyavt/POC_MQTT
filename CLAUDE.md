# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Architecture

This is a secure, production-ready IoT data pipeline that ingests sensor data from F2 Smart Controller devices, transforming raw MQTT messages into structured time-series data for analytics and monitoring. The system implements mTLS authentication, stream processing with Kafka, and high-performance data storage with TimescaleDB.

**Key Features:**
- üîí **Security First**: mTLS authentication, ACL-based authorization, non-root containers
- ‚ö° **High Performance**: Optimized batching, connection pooling, Redis caching
- üìä **Real-time Processing**: Stream processing with Kafka and TimescaleDB
- üêõ **Developer Friendly**: Comprehensive logging, health checks, easy debugging
- üìà **Production Ready**: Monitoring, metrics, horizontal scaling support

### Core Components

1. **Certificate Generation Service** (`services/certgen_api/`): FastAPI service that generates X.509 certificates for devices and brokers using a CA infrastructure
2. **MQTT Broker** (`services/mqtt_broker/`): Mosquitto broker configured with mTLS authentication and ACL-based authorization
3. **FACES2 Controllers Simulator** (`services/faces2_controllers/`): Python simulator for F2 Smart Controller devices that publish sensor data
4. **MQTT-Kafka Connector**: Bridges MQTT messages to Kafka topics for stream processing
5. **Stream Processing**: Apache Kafka handles real-time data processing with optimized batching
6. **Data Storage**: TimescaleDB provides high-performance time-series data storage with PostgreSQL compatibility
7. **Shared Models** (`services/shared/`): Pydantic models for data validation and transformation across services

### Network Architecture

All services communicate through the `iot-network` Docker bridge network.
- FACES2 controllers authenticate to MQTT broker using device certificates
- Broker validates devices using CA certificate
- All certificates are generated by the certgen-api service
- Services communicate internally via Docker bridge network without external credentials

### Data Flow

1. F2 Smart Controllers request certificates from certgen-api during startup
2. Controllers connect to MQTT broker using mTLS authentication
3. Messages are published to topic structure: `<TOPIC_TYPE>/f2-<MAC_ADDR>/<MODE>/<CONNECTOR>/<COMPONENT>`
4. MQTT-Kafka connector streams messages to Kafka topics
5. Stream processing services consume from Kafka for real-time data transformation
6. Processed data is batched and stored in TimescaleDB for analytics

**Architecture Reference**: See the Mermaid diagram in README.md for a visual representation of the complete data pipeline.

## Common Commands

### Docker Operations
```bash
# Start all services
docker-compose up -d

# View logs for specific service
docker-compose logs -f <service-name>

# Rebuild specific service
docker-compose up -d --build <service-name>

# Stop all services
docker-compose down
```

### Certificate Management
The CA and issued certificates are stored in:
- `./ca/`: CA certificate, private key, and OpenSSL configuration
- `./issued/`: Device certificates and keys

## Environment Variables

All environment variables from `.env`:

### Certificate Configuration
- `CA_CN`: Common Name for the CA (default: IoT_CA)
- `CA_EXPIRY`: CA validity in days (default: 3650)
- `BROKER_CN`: Common Name for the MQTT broker (default: mqtt-broker)
- `BROKER_EXPIRY`: Broker certificate validity in days (default: 3650)
- `DEVICE_EXPIRY`: Device certificate validity in days (default: 365)

### Service Configuration
- `OPENSSL_CNF`: Path to OpenSSL configuration file (/ca/openssl.cnf)
- `CA_KEY`: Path to CA private key (/ca/ca.key)
- `CA_CERT`: Path to CA certificate (/ca/ca.crt)
- `MQTT_BROKER_HOST`: MQTT broker hostname (mqtt-broker)
- `CERTGEN_API_HOST`: Certificate generation API hostname (certgen-api)
- `PUBLISH_INTERVAL`: Sensor data publishing interval in seconds (default: 5)

## Development Notes

### Adding New Services

When adding services that need MQTT connectivity:
1. Add certificate provisioning logic similar to faces2_controllers (only for physical devices)
2. Configure mTLS in MQTT client setup (only for physical devices)
3. Add appropriate ACL rules in `services/mqtt_broker/acl`
4. Use shared models from `services/shared/models.py` for data validation
5. Connect to `iot-network` bridge network for internal communication

### MQTT Topic Structure

Follow the established pattern: `<TOPIC_TYPE>/f2-<MAC_ADDR>/<MODE>/<CONNECTOR>/<COMPONENT>`
- `TOPIC_TYPE`: `cmnd` (commands), `stat` (status), `tele` (telemetry)
- Device MAC addresses are used as unique identifiers
- See `docs/mqtt_topics.md` for complete topic specification

### Security Considerations

- FACES2 controllers use mTLS because they simulate physical devices
- MAC addresses are sanitized and validated in certificate generation
- Non-root containers are used throughout
- Secrets are managed through Docker volumes, not environment variables
- Services communicate internally via Docker bridge network without external credentials

### Data Models

Key models in `services/shared/models.py`:

1. **IotMeasurement**: Handles sensor data with timestamp conversion, value extraction from hex strings, field aliasing, and validation
2. **CertificateRequest**: Validates certificate issuance requests with MAC address validation  
3. **CertificateResponse**: Structures certificate response with client cert, private key, CA cert, and expiration

The `IotMeasurement` model is central to data processing and should be extended when adding new sensor types or data formats.